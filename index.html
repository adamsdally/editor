<!doctype html>
<html>
    <head>
        <title>Editor</title>
        <meta charset="utf-8" />
        <style type="text/css">
            main {
                font-size:2em;
            }
            h1, h2, h3, strong {
                font-weight: inherit;
            }
            .bold {
                font-weight: bold;
            }
            .nobold {
                font-weight: normal;
            }
            .italic {
                font-style:italic;
            }
            .blueBorder {
                border:1px solid blue;
            }
            .red {
                color: red;
            }
            strong {
                color: blue;
            }
            article {
                margin:20px;
                padding:20px;
                border:1px solid black;
            }
        </style>
        <script type="text/javascript" src="js/maintainSelection.js"></script>
        <script type="text/javascript" src="js/buildSelection.js"></script>
        <script type="text/javascript" src="js/isActionable.js"></script>
        <script type="text/javascript" src="js/config.js"></script>
        <script type="text/javascript" src="js/getApplyableElementsInParent.js"></script>
        <script type="text/javascript" src="js/Sortable.js"></script>
    </head>
    <body>
        <nav>
            <a href="" class="b-bold" data-action="bold">Bold</a>
            <a href="" class="b-strong" data-action="italic">Italic</a>
            <select data-action="font-size" name="font-size">
                <option value=""></option>
                <option value="16px">16px</option>
                <option value="48px">48px</option>
            </select>
            <select data-action="font-family" name="font-family">
                <option value=""></option>
                <option value="Arial">Arial</option>
                <option value="Lucida Console">Lucida Console</option>
            </select>
            <!--<a href="" data-action="blueBorder">Blue Border</a>-->
        </nav>
        <!--<p><a class="dragging">Dragging Off</a></p>-->
            <!--<h1>Editor Test</h1>
            <p class="test">By: Adam Dally</p>
            <p>Click and type to edit.</p>
            <h2>Hello <strong>World</strong></h2>
            <p>Red Green <strong>Blue</strong> Yellow</p>
            <h3>I AM UNEDITABLE, MUAHHH (but you can drag me)</h3>
            <p>Click and type to edit.</p>-->
        <main>
            <p>Adam<span style="font-size:48px">Dally</span></p>
            <p>Rachel Krieg</p>
        </main>
        <script type="text/javascript">
            //Setup
            el = document.getElementsByTagName('main')[0];
            el.contentEditable = true;

            var blockElements = ['H1', 'H2', 'P'],
                inlineElements = ['SPAN', 'STRONG'];

            var actions = {
                'input' : {
                    'restricted': ['H3'],
                },
                'italic': {
                    'class': 'italic',
                    'restricted': ['H3'],
                },
                'bold': {
                    'class': 'bold',
                    'restricted': ['H3'],
                },
                'font-size': {
                    'attribute': 'font-size',
                    'input': 'select',
                },
                'font-family': {
                    'attribute': 'font-family',
                    'input': 'select',
                },
                'blueBorder': {
                    'class': 'blueBorder',
                },
                'strong':  {
                    'class': '',
                },
            };


            function htmlEncode( input ) {
                return String(input).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, "'").replace(/</g, '&lt;').replace(/>/g, '&gt;');
            }

            var range;
            var selection = window.getSelection();
            var current, start, end;
            var editable = true;
            var draggable = false;
            /*document.getElementsByClassName('dragging')[0].addEventListener('click', function(e) {
                draggable = !draggable;
                el.contentEditable = !draggable;
                if (draggable) {
                    e.target.innerHTML = "Dragging On";
                } else {
                    e.target.innerHTML = "Dragging Off";
                }
            });*/
            el.addEventListener('mouseup', function(e) {
                range = selection.getRangeAt(0);
                if (isRestricted(range.startContainer, actions.input))
                    editable = false;
                else
                    editable = true;
                console.log(range);
                resetControls();
            });

            el.addEventListener('paste', function(e) {
                if (!editable)
                    e.preventDefault();
            });

            el.addEventListener('keypress', function(e) {
                draggable = false;
                //Allow ctrl key compbinations, could be used in the future to access actions
                if (e.ctrlKey)
                    return true;

                //If an arrow key is not pressed and editable is false
                //Then prevent keypress
                if ([37,38,39,40].indexOf(e.keyCode)==-1 && !editable)
                    return e.preventDefault();

                //if backspace or delete aren't pressed then return;
                if ([8,46].indexOf(e.keyCode)==-1)
                    return;

                //check to verify backspace or delete aren't moving into a restricted element
                var range = selection.getRangeAt(0),
                    current,
                    siblingNode;

                if (e.keyCode == 8 && range.startOffset==0) {
                    current = range.startContainer;
                    siblingNode = current.previousElementSibling;
                    while (!siblingNode || !current) {
                        current = current.parentElement;
                        siblingNode = current.previousElementSibling;
                    }
                }
                if (e.keyCode == 46 && range.startOffset==range.startContainer.length) {
                    current = range.startContainer;
                    siblingNode = current.nextElementSibling;

                    while (!siblingNode || current.tagName == "MAIN") {
                        current = current.parentElement;
                        siblingNode = current.nextElementSibling;
                    }
                }
                if (siblingNode && isRestricted(siblingNode, actions.input))
                    e.preventDefault();
            });

            el.addEventListener('keyup', function(e) {
                //On keys that could move the cursor out of its current position check isRestricted
                if ([37,38,39,40].indexOf(e.keyCode)!=-1) {
                    range = selection.getRangeAt(0);
                    if (isRestricted(range.startContainer, actions.input))
                        editable = false;
                    else
                        editable = true;
                }

            });

            function joinAdjacentElements(element) {
                var previous = element.previousSibling;
                var next = element.nextSibling;
                var parent = element.parentElement;
                var movingInside;
                var movingOutside;

                if (previous && previous.nodeType==1 && previous.tagName == element.tagName && previous.className == element.className && previous.style == element.style) {
                    previous.innerHTML += element.innerHTML;
                    parent.removeChild(element);
                    element = previous;
                }
                if (next && next.nodeType==1 && next.tagName == element.tagName && next.className == element.className && next.style == element.style) {
                    element.innerHTML += next.innerHTML;
                    parent.removeChild(next);
                }

                //if we are the only element in parent
                if (parent.children.length == 1) {

                    //Not the best strategy, should move upward to common ancestor

                    //If the parent is inline then move outward and call recursively
                    if (inlineElements.indexOf(parent.tagName) >= 0) {

                        //clone parent and append element
                        movingInside = parent.cloneNode();
                        movingOutside = element.cloneNode();
                        movingInside.innerHTML = element.innerHTML;
                        movingOutside.appendChild(movingInside);

                        //append to parent parent
                        parent.parentElement.appendChild(movingOutside);

                        //delete parent and element
                        parent.removeChild(element);
                        parent.parentElement.removeChild(parent);

                        joinAdjacentElements(movingOutside);

                    }
                }

            }

            function createParentElement(node, tagName) {
                var element = document.createElement(tagName);
                node.parentElement.insertBefore(element, node);
                element.appendChild(node);
                return element;
            }

            function createChildElement(node, tagName) {
                var element = document.createElement(tagName);
                element.innerHTML = node.innerHTML;
                node.innerHTML = "";
                node.appendChild(element);
            }

            function isRestricted(node, action) {
                var current;
                //this is for test purposes.

                if (action.restricted){
                    current = node;
                    while (current.tagName != "MAIN") {
                        if (action.restricted.indexOf(current.tagName) != -1)
                            return true;
                        current = current.parentElement;
                    }
                }
                return false;
            }

            var joinx = 0;
            //------------------------
            //-----Reset Controls-----
            //------------------------
            function resetControls() {
                var range = selection.getRangeAt(0);
                    currentSelection = buildSelection(range),
                    elements = null,
                    i = 0,
                    valueAction = null,
                    valueActions = [],
                    current,
                    part = null;
                joinx = 0;

                //Look through each select element and build a list of actions we need to determine.
                elements = controlsEl.getElementsByTagName('SELECT');
                for (i=0; i<elements.length; i++) {
                    if (elements[i].dataset['action'] && actions[elements[i].dataset['action']]) {
                        valueAction = actions[elements[i].dataset['action']];
                        valueAction.element = elements[i];
                        valueAction.value = null;
                        valueActions.push(valueAction);
                    }
                }

                //Go through each piece of selection and have it determine its valueActions before joining them to the master set.
                defaultValueActions = JSON.parse(JSON.stringify(valueActions));
                for (i=0; i<currentSelection.length; i++) {
                    console.log("{{Next Node}}");
                    current = currentSelection[i];
                    console.log(current);
                    if (current.startOffset || current.endOffset && current.node.length > current.endOffset)
                        part = true;
                    else
                        part = false;
                    joinValues(valueActions, determineValues(current.node, JSON.parse(JSON.stringify(defaultValueActions)), part));
                }

                //Set controls based on values.
                for (i=0; i < valueActions.length; i++) {
                    valueAction = valueActions[i];
                    if (valueAction.value==null)
                        valueAction.value="";
                    for(x = 0; x < valueAction.element.options.length; ++x) {
                        if(valueAction.element.options[x].value === valueAction.value) {
                            valueAction.element.selectedIndex = x;
                            break;
                        }
                    }
                }
            }

            //-------------------------
            //-----Join Values---------
            //-------------------------
            //valueActionsOne and valueActionsTwo are passed by reference
            function joinValues(valueActionsOne, valueActionsTwo) {
                console.log("### Join Values ###");
                console.log(joinx++);
                var i = 0;
                for (i =0; i< valueActionsOne.length; i++) {
                    if (valueActionsOne[i].value == null && valueActionsTwo[i].value!=null)
                        valueActionsOne[i].value = valueActionsTwo[i].value;
                    if (valueActionsOne[i].value != valueActionsTwo[i].value)
                        valueActionsOne[i].value = "";
                }
            }

            //-------------------------
            //-----Determine Values----
            //-------------------------
            //valueActions is currently passed by reference as a clone in the function call, still needs to be returned
            function determineValues(node, valueActions, part) {
                console.log("Determing")
                console.log(node);
                var children,
                    i = 0,
                    oldValueActions,
                    join = false;

                if (node.nodeType == 1) {
                    for (i=0; i<valueActions.length; i++) {
                        if (valueActions[i].attribute && node.style[valueActions[i].attribute])
                            valueActions[i].value = node.style[valueActions[i].attribute];
                    }
                }

                if (part) {
                    console.log("Entering Part");
                    while (blockElements.indexOf(node.tagName) == -1) {
                        newValueActions = JSON.parse(JSON.stringify(valueActions));
                        node = node.parentElement;
                        join = false;
                        for (i=0; i<newValueActions.length; i++) {
                            if (newValueActions[i].attribute && node.style[newValueActions[i].attribute]) {
                                join = true;
                                newValueActions[i].value = node.style[newValueActions[i].attribute];
                            }
                        }

                        if (join)
                            joinValues(valueActions, newValueActions);
                    }
                    for (i=0; i<valueActions.length; i++) {
                        if (valueActions[i].value == null)
                            valueActions[i].value= "";
                    }
                }
                return valueActions;
            }


            //-------------------------
            //-----Appy----------------
            //-------------------------
            function apply(node, action) {
                console.log("Applying:");
                console.log(""+node.innerHTML);
                console.log(JSON.stringify(action));
                var elements,
                    i,
                    parent,
                    remove;
                if (action.negate) {
                    if (action.input) {
                        console.log("Negating an input");
                        node.style[action.attribute] =  action.value;
                    } else
                        node.classList.toggle(action['class'], false);
                    if (blockElements.indexOf(node.tagName)>=0) {
                        remove = true;
                        while(remove) {
                            elements = node.getElementsByClassName(action.class);
                            console.log("NOT CHECKING FOR ATTRIBUTES");
                            if (elements[0])
                                apply(elements[0], action);
                            else
                                remove=false;
                        }
                    } else if (inlineElements.indexOf(node.tagName)>=0) {
                        console.log("NOT CHECKING FOR ATTRIBUTES");
                        if (node.className == "") {
                            parent = node.parentElement;
                            while(node.firstChild) {
                                node.parentElement.insertBefore(node.firstChild, node);
                            }
                            node.parentElement.removeChild(node);
                            //do not normalize this, further stuff is done
                        }
                    }
                    return l();
                } else {
                    if (action.input)
                        node.style[action.attribute] =  action.value;
                    else
                        node.classList.toggle(action['class'], true);
                    return l();
                }
            }

            //------------------------
            //-----Downwards----------
            //------------------------
            function downwards(node, action, startOffset, endOffset, parents) {
                console.log("!!Downwards:");
                console.log(node.innerHTML);
                console.log(JSON.stringify(action));
                /*if (parents.length) {
                    console.log("Parents:");
                    console.log(parents);
                }*/
                var i, childNodes, next, previous, current, action2;
                var parent = node.parentElement;

                if (isRestricted(node, action))
                    return false;

                if (blockElements.indexOf(node.tagName) != -1)
                    return apply(node, action);

                if (inlineElements.indexOf(node.tagName) != -1)
                    return apply(node, action);

                if (node.nodeType ==3 && node.nodeValue.trim())  {

                    //The end needs to be trimmed first so that the offsets aren't messed up
                    if (endOffset && node.length > endOffset){
                        node.splitText(endOffset);
                        next = node.nextSibling;
                    }
                    if (startOffset) {
                        node = node.splitText(startOffset);
                        previous = node.previousSibling;
                    }

                    if (action.negate) {
                        current = node;
                        action2 = JSON.parse(JSON.stringify(action));
                        //As long as the current element is not a block on then do this thing
                        //but negate has to be true
                        console.log("Should I clear block?");
                        while (action2.negate && blockElements.indexOf(current.tagName) == -1) {
                            console.log("try");
                            console.log(JSON.stringify(current));
                            current=current.parentElement;

                            if (hasProperty(current, action)) {
                                console.log("!clear block");
                                apply(current, action);
                                action2.negate = false;
                            }

                        }
                        if (config.debug) {
                            console.log("Action 2, next, previous:");
                            console.log(JSON.stringify(action2));
                            console.log(JSON.stringify(next));
                            console.log(JSON.stringify(previous));
                        }

                        if (!action2.negate) {
                            if (next) {
                                nextNode = createParentElement(next, 'SPAN');
                                apply(nextNode, action2);
                            }
                            if (previous) {
                                previousNode = createParentElement(previous, 'SPAN');
                                apply(previousNode, action2);
                            }
                        }
                    } else {
                        var nextGo = false;
                        var previousGo = false;
                        if (node.nextSibling && node.nextSibling.nodeType != 3)
                            nextGo = (node.nextElementSibling.className == action.class);
                        if (node.previousSibling && node.previousSibling.nodeType != 3)
                            previousGo = (node.previousElementSibling.className == action.class);

                        console.log(JSON.stringify(node));
                        if (nextGo && !previousGo ) {
                            var next = node.nextElementSibling;
                            next.insertBefore(node, next.firstChild);
                        } else if (!nextGo && previousGo) {
                            var previous = node.previousElementSibling;
                            previous.insertBefore(node, null);
                        } else if (nextGo && previousGo) {
                            var previous = node.previousElementSibling;
                            var next = node.nextElementSibling;
                            previous.insertBefore(node, null);
                            previous.insertBefore(next.firstChild, null);
                            previous.parentElement.removeChild(next);
                        } else {
                            node = createParentElement(node, 'SPAN');
                            apply(node, action);
                        }


                        parent.normalize();
                        inner = parent.firstChild;
                        if (parent.childNodes.length == 1) {
                            parent.className = inner.className;
                            parent.insertBefore(inner.firstChild, null);
                            parent.removeChild(inner);
                        }
                    }
                }

                children = node.children;
                parents.push(node.tagName);
                l();
                if (children) {
                    for (i = 0; i<children.length; i++) {
                        downwards(children[i], action, false, false, parents);
                    }
                }
            }

            //------------------------
            //-----Has Property---------
            //------------------------
            function hasProperty(current, action, children) {
                if (action.input) {
                    if (current.style[action.attribute])
                        return true;
                } else {
                    if (current.classList.contains(action.class))
                        return true;
                    if (children && current.getElementsByClassName(action.class).length)
                        return true;
                }
                return false;
            }

            //------------------------
            //-----Perform------------
            //------------------------
            function perform(action) {
                var i = 0,
                    range = selection.getRangeAt(0);
                    currentSelection = buildSelection(range);

                if (config.debug)
                    console.log(currentSelection);

                //determine if action needs to be negated
                //no elements can contain class or attribute, and also can not be inside of class or attribute
                action.negate = false;
                while (action.negate == false && i<currentSelection.length) {
                    current = currentSelection[i].node;
                    console.log("!Trying to negate");
                    console.log(JSON.stringify(current));

                    if (current.nodeType == 1)
                        action.negate = hasProperty(current, action, true);

                    if (current.nodeType == 3) {
                        current= current.parentElement;
                        while (current.tagName != "MAIN") {
                            action.negate = hasProperty(current, action, false);
                            current = current.parentElement;
                        }
                    }

                    i++;
                }
                console.log(action.negate);

                var userSelection = saveSelection(el);
                currentSelection.forEach(function(current) {
                    console.log("++++++++++++Current++++++++++++++++");
                    console.log(current);

                    downwards(current.node, action, current.startOffset, current.endOffset, []);
                    current.node.normalize();
                    console.log(current);
                });
                restoreSelection(el, userSelection);
                console.log("cSel repeat");
                console.log(JSON.stringify(currentSelection));
            }



            var controlsEl = document.getElementsByTagName('NAV')[0];
            document.getElementsByTagName('NAV')[0].addEventListener('change', function(e) {
                var action = null;
                e.preventDefault();

                if (e.target.tagName != 'SELECT')
                    return false;

                l("Change");

                if (e.target.dataset['action'] && actions[e.target.dataset['action']])
                        action = actions[e.target.dataset['action']];
                else
                    return false;
                if (action.input)
                    action.value = e.target.options[e.target.selectedIndex].value;

                perform(action);
            });

            controlsEl.addEventListener('click', function(e) {
                var action = null;
                e.preventDefault();

                if (e.target.tagName != 'A')
                    return false;

                l("Click");

                if (e.target.dataset['action'] && actions[e.target.dataset['action']])
                        action = actions[e.target.dataset['action']];
                else
                    return false;

                perform(action);

                return false;
            });

            //Sortable.create(el); // That's all.
            function l(title) {
                if (!config.debug)
                    return false;

                if (title) {
                    console.log("=============="+title+"================");
                    console.log("===================================");
                } else {
                    console.log("l------------------");
                }

                old = document.getElementsByTagName('article')[0].innerHTML;
                document.getElementsByTagName('article')[0].innerHTML = '<p>'+htmlEncode(el.innerHTML)+'</p>'+old;
            }

            window.addEventListener("load", function load(event){
                window.removeEventListener("load", load, false); //remove listener, no longer needed

                if (config == null)
                    throw "No configuration file found.";

                if (config.debug) {
                    var debugEl = document.createElement('ARTICLE');
                    el.parentElement.insertBefore(debugEl, null);
                }

            },false);

        </script>
    </body>
</html>
