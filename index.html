<!doctype html>
<html>
    <head>
        <title>Editor</title>
        <meta charset="utf-8" />
        <style type="text/css">
            h1, h2, strong {
                font-weight: inherit;
            }
            .bold {
                font-weight: bold;
            }
            strong {
                color: blue;
            }
        </style>
    </head>
    <body>
        <nav>
            <a href="" class="b-bold">Bold</a>
            <a href="" class="b-strong">Strong/Blue</a>
        </nav>
        <main>
            <h1>Editor</h1>
            <h2>Hello <strong>World</strong></h2>

            <p class="test">Adam Dally</p>
            <p>Red green <strong>Blue</strong> yellow</p>
        </main>
        <script type="text/javascript">
            //Setup
            el = document.getElementsByTagName('main')[0];
            el.contentEditable = true;

            var blockElements = ['H1', 'H2', 'P'],
                inlineElements = ['SPAN', 'STRONG'];

            var range;
            var selection;
            var current, start, end;
            el.addEventListener('mouseup', function(e) {
                selection = window.getSelection();
            });

            function joinAdjacentElements(element) {
                var previous = element.previousSibling;
                var next = element.nextSibling;
                var parent = element.parentElement;
                var movingInside;
                var movingOutside;

                if (previous && previous.nodeType==1 && previous.tagName == element.tagName && previous.className == element.className) {
                    previous.innerHTML += element.innerHTML;
                    parent.removeChild(element);
                    element = previous;
                }
                if (next && next.nodeType==1 && next.tagName == element.tagName && next.className == element.className) {
                    element.innerHTML += next.innerHTML;
                    parent.removeChild(next);
                }

                //if we are the only element in parent
                if (parent.children.length == 1) {

                    //Not the best strategy, should move upward to common ancestor

                    //If the parent is inline then move outward and call recursively
                    if (inlineElements.indexOf(parent.tagName) >= 0) {

                        //clone parent and append element
                        movingInside = parent.cloneNode();
                        movingOutside = element.cloneNode();
                        movingInside.innerHTML = element.innerHTML;
                        movingOutside.appendChild(movingInside);

                        //append to parent parent
                        parent.parentElement.appendChild(movingOutside);

                        //delete parent and element
                        parent.removeChild(element);
                        parent.parentElement.removeChild(parent);

                        joinAdjacentElements(movingOutside);

                    }
                }

            }

            function createParentElement(node, tagName) {
                var element = document.createElement(tagName);
                node.parentElement.insertBefore(element, node);
                element.appendChild(node);
            }

            function downwards(node, button, startOffset, endOffset) {
                if (node.nodeType ==3)  {
                    var parent = node.parentElement;

                    if (startOffset)
                        node = node.splitText(startOffset);
                    if (endOffset && node.length > endOffset)
                        node.splitText(endOffset);

                    //If offsets are set then needs to create new inline element around
                    //otherwise use parent

                    if (startOffset || endOffset) {

                    }

                    if (parent.tagName !='SPAN') {
                        createParentElement(node, 'SPAN');
                        node.parentElement.classList = 'bold';
                    } else {
                        /*if (parent.className == 'bold') {
                            masterParent = parent.parentElement;
                            masterParent.insertBefore(node,parent);
                            masterParent.removeChild(parent);

                        }*/
                    }

                    //Not the best strategy, should move upward to common ancestor
                    joinAdjacentElements(node.parentElement);
                    return true;
                }
                var i;
                childNodes = node.childNodes;
                for (i = 0; i<childNodes.length; i++) {
                    downwards(childNodes[i], button);
                }
            }

            document.getElementsByTagName('NAV')[0].addEventListener('click', function(e) {
                e.preventDefault();

                var button = null;
                if (e.target.classList.contains('b-bold'))
                    button = "bold";
                if (e.target.classList.contains('b-strong'))
                    button = "strong";

                if (!button)
                    return;

                var list = [],
                    currentSelection = [],
                    startParent, endParent
                    range = selection.getRangeAt(0);


                /*
                 ------------------Build Selection--------------
                 */


                if (range.startContainer!=range.endContainer) {

                    //Start Container
                    current = range.startContainer;
                    currentSelection.push({
                        node: current,
                        startOffset: range.startOffset
                    });

                    //Find Start Parent
                    while (current.parentElement != range.commonAncestorContainer)
                        current = current.parentElement;
                    startParent = current;

                    //End Container
                    current = range.endContainer;
                    currentSelection.push({
                        node: current,
                        endOffset: range.endOffset
                    });

                    //Find End Parent
                    var sibling;
                    while (current.parentElement != range.commonAncestorContainer)
                        current = current.parentElement;
                    endParent = current;

                    //Build Parents Sideways
                    current = startParent;
                    while ((current.nextElementSibling) && (current.nextElementSibling != endParent)) {
                        current = current.nextElementSibling;
                        currentSelection.push({
                            node: current
                        });
                    }

                    //Build Right from start and up
                    current = range.startContainer;
                    while (current.parentElement != range.commonAncestorContainer) {
                        sibling = current;
                            while (sibling.nextSibling) {
                                sibling = sibling.nextSibling;
                                currentSelection.push({
                                    node: sibling
                                });
                                console.log(sibling);

                            }
                        current = current.parentElement;
                    }

                    //Build Left from end and up
                    current = range.endContainer;
                    while (current.parentElement != range.commonAncestorContainer) {
                        sibling = current;
                        while (sibling.previousSibling) {
                            sibling = sibling.previousSibling;
                            currentSelection.push({
                                node: sibling
                            });
                        }
                        current = current.parentElement;
                    }

                } else {
                    current = range.startContainer;
                    currentSelection.push({
                        node: current,
                        startOffset: range.startOffset,
                        endOffset: range.endOffset,
                    });
                }

                /*
                 ----------- Apply Bold  ----------------
                 */
                console.log(currentSelection);
                currentSelection.forEach(function(current) {
                    downwards(current.node, button, current.startOffset, current.endOffset);
                });

            });



        </script>
    </body>
</html>
